'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * This key derivation code was copied and adapted from:
 *   https://github.com/alepop/ed25519-hd-key/blob/master/src/index.ts
 * in order to remove js-nacl dependency which caused browser errors with
 * content-security-policy - see #12 for details. This modified implementation
 * is a pure JS implementation.
 *
 * The original ed25519-hd-key module is licensed under "GPL-3".
 */

var createHmac = require("create-hmac/browser");

var ED25519_CURVE = 'ed25519 seed';
var HARDENED_OFFSET = 0x80000000;

var derivePath = exports.derivePath = function derivePath(path, seed) {
    if (!isValidPath(path)) {
        throw new Error('Invalid derivation path');
    }

    var _getMasterKeyFromSeed = getMasterKeyFromSeed(seed),
        key = _getMasterKeyFromSeed.key,
        chainCode = _getMasterKeyFromSeed.chainCode;

    var segments = path.split('/').slice(1).map(replaceDerive).map(function (el) {
        return parseInt(el, 10);
    });
    return segments.reduce(function (parentKeys, segment) {
        return CKDPriv(parentKeys, segment + HARDENED_OFFSET);
    }, { key: key, chainCode: chainCode });
};

var getMasterKeyFromSeed = function getMasterKeyFromSeed(seed) {
    var hmac = createHmac('sha512', ED25519_CURVE);
    var I = hmac.update(Buffer.from(seed, 'hex')).digest();
    var IL = I.slice(0, 32);
    var IR = I.slice(32);
    return {
        key: IL,
        chainCode: IR
    };
};

var CKDPriv = function CKDPriv(_ref, index) {
    var key = _ref.key,
        chainCode = _ref.chainCode;

    var indexBuffer = Buffer.allocUnsafe(4);
    indexBuffer.writeUInt32BE(index, 0);
    var data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);
    var I = createHmac('sha512', chainCode).update(data).digest();
    var IL = I.slice(0, 32);
    var IR = I.slice(32);
    return {
        key: IL,
        chainCode: IR
    };
};

var replaceDerive = function replaceDerive(val) {
    return val.replace("'", '');
};
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var isValidPath = function isValidPath(path) {
    if (!pathRegex.test(path)) {
        return false;
    }
    return !path.split('/').slice(1).map(replaceDerive).some(isNaN);
};